Data Integrity -> The data stored in oracle db should follow certain business rules. 
      eg :reg no - has to be unique 
      Gender -> should have either male or Female value only
      Date of joining -> should be lesser than the current system date.
      
Ways to ensure Data Integrity 
  Enforcing business rules with triggered stored database proedures
  Enforcing the business rules in the code of a database application.(i.e making validations in the application UI when the data is entered).
  Oracle Database integrity constraints which are rules defined at the column or object level that restrict values in the database.
  Using stored procedures to completely control access to data.
  
Integrity Contraint - a rule that restricts the values in a database. 
Use a contraint to define an integrity constraint.

Constraints -> Validate the data for business rules before getting stored into the table.
        Constraints are created as part of the table definition itself.
        The rules are centralized. The data entered by all applications has to adhere to the same integrity constraints.
        Flexibilty . integrity constraints can be disabled and enabled.
                      integrity constraints can be disabled temmporarily to avoid performance overhead when loading large amounts of data.

Types of Contraints- NOT NULL, Unique Key, Primary Key, Foreign Key, Check, REF

NOT NULL - prohibits a column from having null values.

eg : create table emp(empno number, 
      ename varchar2(100) null, 
      address1 varchar2(100) constraint address_not_null not null, 
      address2 varchar2(100) not null,
      address2 varchar3(100)
      );
by default there will be null constraint.Even if null is explicitly mentioned , it will not be in the meta data information.
In the above eg address_not_null is the name of the constraint which is optional. 
address2 will get created with system defined constraint name.

meta data information
      select * from user_constraints where table_name ='EMP';
      select * from user_cons_columns where table_name ='EMP'
Disabling a constraint -> alter table emp disable constraint address_not_null_cons;
      By default the constraint will be created with the enable mode, if we want to create it with disable mode see the below eg:
      eg: address1 varchar2(100) constraint address_not_null not null disable, 
Drop a constraint-> Alter table emp drop constraint address_not_null;

Unique key Constraint -> A unique constraint is a single field or combination of fields that uniquely defines a record.
      Some of the fields can contain null values as long as the combination of values is unique.
 Eg:
 CREATE TABLE supplier
( supplier_id numeric(10) NOT NULL,
  supplier_name varchar2(50) NOT NULL,
  contact_name varchar2(50),
  CONSTRAINT supplier_unique UNIQUE (supplier_id, supplier_name)
);

Primary Key Constraint :In Oracle, a primary key is a single field or combination of fields that uniquely defines a record. 
None of the fields that are part of the primary key can contain a null value. A table can have only one primary key.
In Oracle, a primary key can not contain more than 32 columns.
Eg: 
CREATE TABLE supplier
(
  supplier_id numeric(10) not null,
  supplier_name varchar2(50) not null,
  contact_name varchar2(50),
  CONSTRAINT supplier_pk PRIMARY KEY (supplier_id, supplier_name)
);

The `GENERATED BY DEFAULT AS IDENTITY` clause was introduced in **Oracle Database 12c** (version 12.1) as part of Oracle's support for **identity columns**. This feature simplifies the creation of auto-incrementing primary keys, similar to how identity columns work in other databases like MySQL or SQL Server.

Before Oracle 12c, you had to use sequences and triggers to auto-generate unique values for primary key columns. With the introduction of identity columns in Oracle 12c, you can now easily define auto-incrementing values directly in the table definition.

### Example of `GENERATED BY DEFAULT AS IDENTITY`:

```sql
CREATE TABLE employees (
  employee_id NUMBER GENERATED BY DEFAULT AS IDENTITY,
  first_name  VARCHAR2(50),
  last_name   VARCHAR2(50)
);
```

### Types of Identity Columns in Oracle:

1. **`GENERATED ALWAYS AS IDENTITY`**:
   - The column value is always auto-generated, and you cannot explicitly insert a value into the identity column.

2. **`GENERATED BY DEFAULT AS IDENTITY`**:
   - The column value is auto-generated by default, but you can explicitly insert a value into the identity column if needed.

#### Example of `GENERATED ALWAYS AS IDENTITY`:
```sql
CREATE TABLE departments (
  department_id NUMBER GENERATED ALWAYS AS IDENTITY,
  department_name VARCHAR2(50)
);
```

With this new feature in Oracle 12c, creating auto-incrementing primary keys became much easier and more efficient.

Question1 : Table with duplicate entries in production, cannot delete existing rows , However want to prevent further duplicate rows to get inserted?
            Alter table emp add constraint empno_pk_cons primary key(empno) deferrable novalidate;
            The deferrable novalidate keyword added to the constraint will not validate the existing rows in the table but
      it will validate all the further dml operations that are performed in the table.
            We Will not be to create a constraint using alter table statement for table with duplicate rows without the deferrable novalidate
            keyword. If we try it will throw duplicate values exception.

Question2 : Does Creating a primary key constraint always create an index automatically?
    Creating a primary key constraint creates an index automatically but not in all cases.
    Creating a primary key will create a unique index , if an index is not created on the column already.
    
    If an index is already created on the column, creating primary key will not create an unique index.
    Eg: step1 : create table emp(empno number, ename ,varchar2(100));
        step2 : alter table emp add constraint empno_pk_cons primary key(empno);
        step3 : select * from user_constraints where table_name ='EMP';
        step4:  select * from user_tablindexes where  table_name ='EMP';
    Before step2 if : "create index t1 on emp(empno);" statement is used it will create a non unique index. 
    In that case creating a primary key constraint  will not create an unique index.
    
    Note1: Creating a primary key will create a non unique index when "deferrable novalidate" keyword is used.
    Note2: scenario1-> Dropping a constraint will drop the underlying index provided the index was created as part of the constraint creation.
           scenario2-> if the index is created first and constraint is created to the table later using alter statement , then additionaly when drop index clause
           is used the constraint will get dropped along with the index.
           eg scenario2: Alter table T drop constraint T_PK1 drop index;
    Note3: Dropping the table will drop the index , constraints and triggers associated with the table.
    
Question3 :We use unique index or unique constraint to enforce uniqueness of a column. What's the difference? And when to use what?
          Unique constraint automatically creates an unique index ( but not always).
          Unique constraint is for data integrity whereas unique index is for performance improvement.
          Foreign Key can be created over a unique constraint, not over a unique index.
          Sometimes, we might be interested to create a unique index but not a unique constraint.
          Note if we create a unique index and not create a primary key or not null constraint it will restrict duplicate values in the
         columns without null. it does not restrict null value duplication.
          
 Question4 :How many null values are allowed on Unique Constraint column in Oracle?
       Null is not equal to anything in oracle. We cannot compare null using the = operator. 
       The comparison can be done using a) nvl(variable_1,'@')=nvl(variable_2,'@'); b) variable_1 is null and variable_2 is null.
       As each null value is different from one another in oracle (since null is not equal to null). When unique key constraint is in place in a column
       in Oracle ,any number of null values can be there in the column. If the same is done in a column with primary key constraint , 
       inserting null values is not possible.
       The unique key constraint behaves in a different way i different dbs like sql server.
 
 Question5: Can We create Primary Key, NOT NULL and Unique Key constraint in the same column?
      In oracle db we will not be able to create Unique and Primary key constraint on the same column.
              we will be able to create NOT NULL and primary key constraint together.
              The behavious varies across different db's like mysql, sqlserver.


Absolutely! Let's go through the **CHECK** constraint in Oracle, rectifying the mistake regarding the use of non-deterministic functions like `SYSDATE`.

### Overview of the `CHECK` Constraint

A **CHECK** constraint in Oracle is used to enforce data integrity by specifying a condition that each row in a table must satisfy. When the condition evaluates to `FALSE` or is violated, Oracle raises an error, preventing invalid data from being inserted or updated.

### Key Points:
1. A `CHECK` constraint can be defined on one or more columns.
2. It ensures that only valid data, as per the condition, is inserted into the table.
3. The condition can involve comparison operators, arithmetic operations, logical operators (`AND`, `OR`, `NOT`), and more.
4. **Important**: The condition must be **deterministic** — meaning that it must always return the same result for the same input. This means functions like `SYSDATE` are not allowed in `CHECK` constraints.

### Correct Use of `CHECK` Constraints with Examples:

#### Example 1: Simple `CHECK` Constraint on a Single Column

Let’s ensure that the `salary` column of an `employees` table is always greater than 1000.

#### SQL Example:
```sql
CREATE TABLE employees (
  employee_id   NUMBER PRIMARY KEY,
  first_name    VARCHAR2(50),
  last_name     VARCHAR2(50),
  salary        NUMBER,
  CONSTRAINT chk_salary CHECK (salary > 1000)
);
```

#### Inserting Valid and Invalid Data:
```sql
-- Valid Insert (salary is greater than 1000)
INSERT INTO employees (employee_id, first_name, last_name, salary)
VALUES (1, 'John', 'Doe', 1500);

-- Invalid Insert (salary is less than 1000)
INSERT INTO employees (employee_id, first_name, last_name, salary)
VALUES (2, 'Jane', 'Doe', 800);
```

#### Output for Invalid Data:
```
ORA-02290: check constraint (SCHEMA_NAME.CHK_SALARY) violated
```

---

#### Example 2: `CHECK` Constraint with Logical Operators

You can create a `CHECK` constraint with more complex conditions, such as ensuring that a `salary` is between 2000 and 10000.

#### SQL Example:
```sql
ALTER TABLE employees
ADD CONSTRAINT chk_salary_range CHECK (salary >= 2000 AND salary <= 10000);
```

#### Inserting Valid and Invalid Data:
```sql
-- Valid Insert (salary within the range 2000-10000)
INSERT INTO employees (employee_id, first_name, last_name, salary)
VALUES (3, 'Alice', 'Smith', 5000);

-- Invalid Insert (salary outside the range)
INSERT INTO employees (employee_id, first_name, last_name, salary)
VALUES (4, 'Bob', 'Johnson', 15000);
```

#### Output for Invalid Data:
```
ORA-02290: check constraint (SCHEMA_NAME.CHK_SALARY_RANGE) violated
```

---

#### Example 3: `CHECK` Constraint with Multiple Columns

Let’s say we want to ensure that the `commission` for an employee must always be less than the `salary`.

#### SQL Example:
```sql
ALTER TABLE employees
ADD CONSTRAINT chk_commission_salary CHECK (commission < salary);
```

#### Inserting Valid and Invalid Data:
```sql
-- Valid Insert (commission is less than salary)
INSERT INTO employees (employee_id, first_name, last_name, salary, commission)
VALUES (5, 'Carol', 'Lee', 6000, 500);

-- Invalid Insert (commission is greater than salary)
INSERT INTO employees (employee_id, first_name, last_name, salary, commission)
VALUES (6, 'David', 'Kim', 4000, 5000);
```

#### Output for Invalid Data:
```
ORA-02290: check constraint (SCHEMA_NAME.CHK_COMMISSION_SALARY) violated
```

---

#### Example 4: `CHECK` Constraint with Specific Allowed Values

We can use a `CHECK` constraint to restrict the values that a column can take. For example, ensuring that the `department` can only have specific values like 'HR', 'Finance', or 'IT'.

#### SQL Example:
```sql
ALTER TABLE employees
ADD CONSTRAINT chk_department CHECK (department IN ('HR', 'Finance', 'IT'));
```

#### Inserting Valid and Invalid Data:
```sql
-- Valid Insert (department is one of the allowed values)
INSERT INTO employees (employee_id, first_name, last_name, salary, department)
VALUES (7, 'Eve', 'Miller', 3000, 'IT');

-- Invalid Insert (department is not one of the allowed values)
INSERT INTO employees (employee_id, first_name, last_name, salary, department)
VALUES (8, 'Frank', 'Brown', 4000, 'Marketing');
```

#### Output for Invalid Data:
```
ORA-02290: check constraint (SCHEMA_NAME.CHK_DEPARTMENT) violated
```

---

### Correct Approach for Date Constraints

As discussed earlier, **non-deterministic functions** like `SYSDATE` cannot be used in `CHECK` constraints. If you want to enforce a rule like "hire date must be in the past," you can achieve this using **triggers** instead of `CHECK` constraints.

#### Example 5: Enforcing Hire Date with a Trigger

You can create a trigger to ensure that the `hire_date` is never set to a future date.

#### SQL Example:
```sql
CREATE OR REPLACE TRIGGER trg_hire_date_check
BEFORE INSERT OR UPDATE ON employees
FOR EACH ROW
BEGIN
  IF :NEW.hire_date > SYSDATE THEN
    RAISE_APPLICATION_ERROR(-20001, 'Hire date cannot be in the future.');
  END IF;
END;
/
```

#### Inserting Valid and Invalid Data:
```sql
-- Valid Insert (hire_date is in the past)
INSERT INTO employees (employee_id, first_name, last_name, salary, hire_date)
VALUES (9, 'Grace', 'Taylor', 4500, TO_DATE('01-JAN-2020', 'DD-MON-YYYY'));

-- Invalid Insert (hire_date is in the future)
INSERT INTO employees (employee_id, first_name, last_name, salary, hire_date)
VALUES (10, 'Hank', 'Wilson', 5500, TO_DATE('01-JAN-2025', 'DD-MON-YYYY'));
```

#### Output for Invalid Data:
```
ORA-20001: Hire date cannot be in the future.
```

---

### Conclusion:
1. **CHECK constraints** enforce data integrity rules by limiting the values allowed in columns based on a specified condition.
2. **Non-deterministic functions** like `SYSDATE` are not allowed in `CHECK` constraints.
3. For complex validations (like checking dates against the current system date), **triggers** or application-level validations should be used instead.
4. **Common scenarios** include ensuring value ranges, restricting values to specific domains, and applying conditions across multiple columns.

Let me know if you have further questions or need more examples!

The statement **"The number one cause of deadlock is unindexed foreign keys"** refers to a common issue in databases where foreign key constraints are not properly indexed, leading to increased chances of deadlocks during concurrent `INSERT`, `UPDATE`, or `DELETE` operations. Let me explain why this happens and how it relates to deadlocks.

### Key Concepts:
1. **Foreign Key**: A foreign key in a table references the primary key or unique key in another table. It ensures referential integrity, meaning that every value in the foreign key column(s) must exist in the referenced primary key/unique key column(s).
   
2. **Deadlock**: A deadlock occurs when two or more transactions are waiting for each other to release resources (such as row-level locks), causing a cycle of dependency where none of the transactions can proceed.

### Why Unindexed Foreign Keys Can Cause Deadlocks

When you perform **DML operations** (especially `DELETE` or `UPDATE`) on a parent table that has a foreign key relationship to a child table, Oracle needs to ensure that the referential integrity of the data is maintained. To do this, it checks whether the foreign key constraint in the child table is violated.

#### Unindexed Foreign Key Scenario:

If the foreign key columns in the child table are **not indexed**, Oracle will have to **perform a full table scan** on the child table to check for matching rows whenever a `DELETE` or `UPDATE` occurs in the parent table. If there are concurrent DML operations occurring on the child table, this can lead to deadlocks because of the following reasons:

1. **Lock escalation**: Without an index on the foreign key, Oracle may need to lock a large number of rows in the child table during the full table scan. If multiple transactions are trying to modify the child table at the same time, they may acquire locks on different sets of rows in an inconsistent order, leading to a deadlock.

2. **Increased locking duration**: A full table scan takes longer than an index lookup. During this time, rows in both the parent and child tables remain locked, increasing the chances of another transaction coming in and trying to lock the same rows, causing a deadlock.

3. **Locking pattern conflict**: If two transactions try to modify the parent and child tables in a different order, they can each acquire locks that the other transaction needs, leading to a situation where both transactions are waiting for the other to release the lock, resulting in a deadlock.

### Example of Deadlock due to Unindexed Foreign Key

Let's consider a simple parent-child relationship between two tables: `orders` (parent) and `order_items` (child). The `order_items` table has a foreign key (`order_id`) that references the `orders` table.

#### 1. Table structure:

```sql
-- Parent table (orders)
CREATE TABLE orders (
    order_id NUMBER PRIMARY KEY,
    order_date DATE
);

-- Child table (order_items) with unindexed foreign key
CREATE TABLE order_items (
    item_id NUMBER PRIMARY KEY,
    order_id NUMBER,
    product_name VARCHAR2(50),
    FOREIGN KEY (order_id) REFERENCES orders(order_id)
);
```

Notice that there is no index on the `order_id` column in the `order_items` table (the foreign key).

#### 2. DML operations leading to a deadlock:

- **Transaction A**:
    1. Deletes a row from the `orders` table (parent).
    2. Oracle tries to check the foreign key constraint, scanning the `order_items` table to ensure no child rows depend on the deleted parent row.
  
- **Transaction B**:
    1. Inserts or updates a row in the `order_items` table (child).
    2. This transaction tries to lock the child table row that the parent row in Transaction A is dependent on.

If these two transactions occur concurrently, Oracle may lock rows in the parent and child tables in a conflicting order, leading to a deadlock.

#### 3. Deadlock detection:
Oracle will detect the deadlock and will automatically terminate one of the transactions with an error like:

```sql
ORA-00060: deadlock detected while waiting for resource
```

### Solution: Index the Foreign Key

The best way to prevent deadlocks due to unindexed foreign keys is to **create an index on the foreign key column(s)** in the child table. This allows Oracle to efficiently check for foreign key constraints using the index rather than scanning the entire child table.

#### Creating an Index on the Foreign Key:
```sql
-- Create an index on the foreign key (order_id) in the child table
CREATE INDEX idx_order_items_order_id ON order_items(order_id);
```

This index allows Oracle to quickly locate the rows in the `order_items` table that reference the `orders` table without locking a large number of rows, significantly reducing the risk of deadlocks.

### Key Benefits of Indexing Foreign Keys:
1. **Efficient constraint checking**: Oracle can efficiently check for matching rows in the child table without a full table scan.
2. **Reduced locking duration**: The index lookup is much faster than a full table scan, reducing the time locks are held.
3. **Minimized risk of deadlocks**: Since Oracle can quickly find the relevant rows in the child table using the index, the chances of deadlocks due to lock escalation or conflicting locking patterns are greatly reduced.

### Summary:
- **Unindexed foreign keys** can cause deadlocks because Oracle has to perform full table scans on the child table to enforce foreign key constraints, which leads to long-lasting locks and conflicting lock acquisition.
- By **indexing the foreign key** column(s) in the child table, you ensure faster lookups for foreign key constraint enforcement, reducing the risk of deadlocks.

 
 
 
      
