Data Integrity -> The data stored in oracle db should follow certain business rules. 
      eg :reg no - has to be unique 
      Gender -> should have either male or Female value only
      Date of joining -> should be lesser than the current system date.
      
Ways to ensure Data Integrity 
  Enforcing business rules with triggered stored database proedures
  Enforcing the business rules in the code of a database application.(i.e making validations in the application UI when the data is entered).
  Oracle Database integrity constraints which are rules defined at the column or object level that restrict values in the database.
  Using stored procedures to completely control access to data.
  
Integrity Contraint - a rule that restricts the values in a database. 
Use a contraint to define an integrity constraint.

Constraints -> Validate the data for business rules before getting stored into the table.
        Constraints are created as part of the table definition itself.
        The rules are centralized. The data entered by all applications has to adhere to the same integrity constraints.
        Flexibilty . integrity constraints can be disabled and enabled.
                      integrity constraints can be disabled temmporarily to avoid performance overhead when loading large amounts of data.

Types of Contraints- NOT NULL, Unique Key, Primary Key, Foreign Key, Check, REF

NOT NULL - prohibits a column from having null values.

eg : create table emp(empno number, 
      ename varchar2(100) null, 
      address1 varchar2(100) constraint address_not_null not null, 
      address2 varchar2(100) not null,
      address2 varchar3(100)
      );
by default there will be null constraint.Even if null is explicitly mentioned , it will not be in the meta data information.
In the above eg address_not_null is the name of the constraint which is optional. 
address2 will get created with system defined constraint name.

meta data information
      select * from user_constraints where table_name ='EMP';
      select * from user_cons_columns where table_name ='EMP'
Disabling a constraint -> alter table emp disable constraint address_not_null_cons;
      By default the constraint will be created with the enable mode, if we want to create it with disable mode see the below eg:
      eg: address1 varchar2(100) constraint address_not_null not null disable, 
Drop a constraint-> Alter table emp drop constraint address_not_null;

Unique key Constraint -> A unique constraint is a single field or combination of fields that uniquely defines a record.
      Some of the fields can contain null values as long as the combination of values is unique.
 Eg:
 CREATE TABLE supplier
( supplier_id numeric(10) NOT NULL,
  supplier_name varchar2(50) NOT NULL,
  contact_name varchar2(50),
  CONSTRAINT supplier_unique UNIQUE (supplier_id, supplier_name)
);

Primary Key Constraint :In Oracle, a primary key is a single field or combination of fields that uniquely defines a record. 
None of the fields that are part of the primary key can contain a null value. A table can have only one primary key.
In Oracle, a primary key can not contain more than 32 columns.
Eg: 
CREATE TABLE supplier
(
  supplier_id numeric(10) not null,
  supplier_name varchar2(50) not null,
  contact_name varchar2(50),
  CONSTRAINT supplier_pk PRIMARY KEY (supplier_id, supplier_name)
);

Question1 : Table with duplicate entries in production, cannot delete existing rows , However want to prevent further duplicate rows to get inserted?
            Alter table emp add constraint empno_pk_cons primary key(empno) deferrable novalidate;
            The deferrable novalidate keyword added to the constraint will not validate the existing rows in the table but
      it will validate all the further dml operations that are performed in the table.
            We Will not be to create a constraint using alter table statement for table with duplicate rows without the deferrable novalidate
            keyword. If we try it will throw duplicate values exception.

Question2 : Does Creating a primary key constraint always create an index automatically?
    Creating a primary key constraint creates an index automatically but not in all cases.
    Creating a primary key will create a unique index , if an index is not created on the column already.
    
    If an index is already created on the column, creating primary key will not create an unique index.
    Eg: step1 : create table emp(empno number, ename ,varchar2(100));
        step2 : alter table emp add constraint empno_pk_cons primary key(empno);
        step3 : select * from user_constraints where table_name ='EMP';
        step4:  select * from user_tablindexes where  table_name ='EMP';
    Before step2 if : "create index t1 on emp(empno);" statement is used it will create a non unique index. 
    In that case creating a primary key constraint  will not create an unique index.
    
    Note1: Creating a primary key will create a non unique index when "deferrable novalidate" keyword is used.
    Note2: scenario1-> Dropping a constraint will drop the underlying index provided the index was created as part of the constraint creation.
           scenario2-> if the index is created first and constraint is created to the table later using alter statement , then additionaly when drop index clause
           is used the constraint will get dropped along with the index.
           eg scenario2: Alter table T drop constraint T_PK1 drop index;
    Note3: Dropping the table will drop the index , constraints and triggers associated with the table.
    
Question3 :We use unique index or unique constraint to enforce uniqueness of a column. What's the difference? And when to use what?
          Unique constraint automatically creates an unique index ( but not always).
          Unique constraint is for data integrity whereas unique index is for performance improvement.
          Foreign Key can be created over a unique constraint, not over a unique index.
          Sometimes, we might be interested to create a unique index but not a unique constraint.
          Note if we create a unique index and not create a primary key or not null constraint it will restrict duplicate values in the
         columns without null. it does not restrict null value duplication.
          
 Question4 :How many null values are allowed on Unique Constraint column in Oracle?
       Null is not equal to anything in oracle. We cannot compare null using the = operator. 
       The comparison can be done using a) nvl(variable_1,'@')=nvl(variable_2,'@'); b) variable_1 is null and variable_2 is null.
       As each null value is different from one another in oracle (since null is not equal to null). When unique key constraint is in place in a column
       in Oracle ,any number of null values can be there in the column. If the same is done in a column with primary key constraint , 
       inserting null values is not possible.
       The unique key constraint behaves in a different way i different dbs like sql server.
 
 Question5: Can We create Primary Key, NOT NULL and Unique Key constraint in the same column?
      In oracle db we will not be able to create Unique and Primary key constraint on the same column.
              we will be able to create NOT NULL and primary key constraint together.
              The behavious varies across different db's like mysql, sqlserver.


Absolutely! Let's go through the **CHECK** constraint in Oracle, rectifying the mistake regarding the use of non-deterministic functions like `SYSDATE`.

### Overview of the `CHECK` Constraint

A **CHECK** constraint in Oracle is used to enforce data integrity by specifying a condition that each row in a table must satisfy. When the condition evaluates to `FALSE` or is violated, Oracle raises an error, preventing invalid data from being inserted or updated.

### Key Points:
1. A `CHECK` constraint can be defined on one or more columns.
2. It ensures that only valid data, as per the condition, is inserted into the table.
3. The condition can involve comparison operators, arithmetic operations, logical operators (`AND`, `OR`, `NOT`), and more.
4. **Important**: The condition must be **deterministic** — meaning that it must always return the same result for the same input. This means functions like `SYSDATE` are not allowed in `CHECK` constraints.

### Correct Use of `CHECK` Constraints with Examples:

#### Example 1: Simple `CHECK` Constraint on a Single Column

Let’s ensure that the `salary` column of an `employees` table is always greater than 1000.

#### SQL Example:
```sql
CREATE TABLE employees (
  employee_id   NUMBER PRIMARY KEY,
  first_name    VARCHAR2(50),
  last_name     VARCHAR2(50),
  salary        NUMBER,
  CONSTRAINT chk_salary CHECK (salary > 1000)
);
```

#### Inserting Valid and Invalid Data:
```sql
-- Valid Insert (salary is greater than 1000)
INSERT INTO employees (employee_id, first_name, last_name, salary)
VALUES (1, 'John', 'Doe', 1500);

-- Invalid Insert (salary is less than 1000)
INSERT INTO employees (employee_id, first_name, last_name, salary)
VALUES (2, 'Jane', 'Doe', 800);
```

#### Output for Invalid Data:
```
ORA-02290: check constraint (SCHEMA_NAME.CHK_SALARY) violated
```

---

#### Example 2: `CHECK` Constraint with Logical Operators

You can create a `CHECK` constraint with more complex conditions, such as ensuring that a `salary` is between 2000 and 10000.

#### SQL Example:
```sql
ALTER TABLE employees
ADD CONSTRAINT chk_salary_range CHECK (salary >= 2000 AND salary <= 10000);
```

#### Inserting Valid and Invalid Data:
```sql
-- Valid Insert (salary within the range 2000-10000)
INSERT INTO employees (employee_id, first_name, last_name, salary)
VALUES (3, 'Alice', 'Smith', 5000);

-- Invalid Insert (salary outside the range)
INSERT INTO employees (employee_id, first_name, last_name, salary)
VALUES (4, 'Bob', 'Johnson', 15000);
```

#### Output for Invalid Data:
```
ORA-02290: check constraint (SCHEMA_NAME.CHK_SALARY_RANGE) violated
```

---

#### Example 3: `CHECK` Constraint with Multiple Columns

Let’s say we want to ensure that the `commission` for an employee must always be less than the `salary`.

#### SQL Example:
```sql
ALTER TABLE employees
ADD CONSTRAINT chk_commission_salary CHECK (commission < salary);
```

#### Inserting Valid and Invalid Data:
```sql
-- Valid Insert (commission is less than salary)
INSERT INTO employees (employee_id, first_name, last_name, salary, commission)
VALUES (5, 'Carol', 'Lee', 6000, 500);

-- Invalid Insert (commission is greater than salary)
INSERT INTO employees (employee_id, first_name, last_name, salary, commission)
VALUES (6, 'David', 'Kim', 4000, 5000);
```

#### Output for Invalid Data:
```
ORA-02290: check constraint (SCHEMA_NAME.CHK_COMMISSION_SALARY) violated
```

---

#### Example 4: `CHECK` Constraint with Specific Allowed Values

We can use a `CHECK` constraint to restrict the values that a column can take. For example, ensuring that the `department` can only have specific values like 'HR', 'Finance', or 'IT'.

#### SQL Example:
```sql
ALTER TABLE employees
ADD CONSTRAINT chk_department CHECK (department IN ('HR', 'Finance', 'IT'));
```

#### Inserting Valid and Invalid Data:
```sql
-- Valid Insert (department is one of the allowed values)
INSERT INTO employees (employee_id, first_name, last_name, salary, department)
VALUES (7, 'Eve', 'Miller', 3000, 'IT');

-- Invalid Insert (department is not one of the allowed values)
INSERT INTO employees (employee_id, first_name, last_name, salary, department)
VALUES (8, 'Frank', 'Brown', 4000, 'Marketing');
```

#### Output for Invalid Data:
```
ORA-02290: check constraint (SCHEMA_NAME.CHK_DEPARTMENT) violated
```

---

### Correct Approach for Date Constraints

As discussed earlier, **non-deterministic functions** like `SYSDATE` cannot be used in `CHECK` constraints. If you want to enforce a rule like "hire date must be in the past," you can achieve this using **triggers** instead of `CHECK` constraints.

#### Example 5: Enforcing Hire Date with a Trigger

You can create a trigger to ensure that the `hire_date` is never set to a future date.

#### SQL Example:
```sql
CREATE OR REPLACE TRIGGER trg_hire_date_check
BEFORE INSERT OR UPDATE ON employees
FOR EACH ROW
BEGIN
  IF :NEW.hire_date > SYSDATE THEN
    RAISE_APPLICATION_ERROR(-20001, 'Hire date cannot be in the future.');
  END IF;
END;
/
```

#### Inserting Valid and Invalid Data:
```sql
-- Valid Insert (hire_date is in the past)
INSERT INTO employees (employee_id, first_name, last_name, salary, hire_date)
VALUES (9, 'Grace', 'Taylor', 4500, TO_DATE('01-JAN-2020', 'DD-MON-YYYY'));

-- Invalid Insert (hire_date is in the future)
INSERT INTO employees (employee_id, first_name, last_name, salary, hire_date)
VALUES (10, 'Hank', 'Wilson', 5500, TO_DATE('01-JAN-2025', 'DD-MON-YYYY'));
```

#### Output for Invalid Data:
```
ORA-20001: Hire date cannot be in the future.
```

---

### Conclusion:
1. **CHECK constraints** enforce data integrity rules by limiting the values allowed in columns based on a specified condition.
2. **Non-deterministic functions** like `SYSDATE` are not allowed in `CHECK` constraints.
3. For complex validations (like checking dates against the current system date), **triggers** or application-level validations should be used instead.
4. **Common scenarios** include ensuring value ranges, restricting values to specific domains, and applying conditions across multiple columns.

Let me know if you have further questions or need more examples!
 
 
 
      
